# Observability 可观测性
对于性能问题来说，分析是第一步。可观测的概念也给分析提供了一些指导。谈谈个人对可观测概念的理解。

## Logs vs Metrics vs Traces
可观测中提出了三个可观测的数据来源
![three](pics/observability_signals.png)
打个比方，类似于看电影的那个进度条，现在进度条会有这个观看量的一个波形图，那个就是一种metrics的体现；然后对于电影的高能点，进度条也会有个高亮的点，那个就是一种log的体现；如果你对于某一段影片感兴趣，通过拉片的方式去观看学习，那个就是一种trace的体现。

### Metrics 指标
指标通常是一些统计数值，是聚合后的数据，也因此其对于系统的观测来说粒度相对较粗。好处就是采集和数据预处理的效率很高，观察者效应可以得到有效的控制。所以非常适合用于系统日常信息的监测和自动告警。
从能力建设的难易程度上来看，从系统中获取指标数据的能力也相对好建设。
比如`perf stat`就可以采集一些基础指标。

### Logs 日志
日志数据可以提供一些组件发生的离散事件的信息，是非常传统的一种可观测数据来源。其信息可以是具体错误，可以是错误调用栈，也可以是指标。好处就是日志数据的信息种类丰富，内容也比单纯的指标数据详实很多，可以提供丰富的错误相关信息用于排查。坏处就是如果日志数据需要在系统运行时就进行大量的采集和预处理，可能会导致观察者效益影响系统运行。所以一般情况下系统只做日志的采集，通过指标数据发现问题后，再通过观察日志发现来更具体的问题。
通过日志数据来观测，对组件有一定了解的开发人员会比较高效。其他人员最好配合开发人员编写的常见错误排查手册。

### Trace 跟踪
跟踪相比于上述两个数据来源，更像是一种理念，一种方法论，和开发过程中的跟踪调试一样，期望观测系统某一次执行流或者数据流的具体信息，trace的数据并不限于某种数据形式，既可以是metrics也可以是log。trace有两种使用场景，一种是用于溯源复杂的错误，一种是用于优化。著名的火焰图就是一种trace。
要建立完整完善的跟踪能力，是一个有挑战性的任务，需要了解系统中各个组件关联（包括但不止于调用关系）。具体实现上，在服务间传递一个唯一标识符来识别某次具体的跟踪，不容易跟丢。

## reference 
1. [Logs vs Metrics vs Traces](https://microsoft.github.io/code-with-engineering-playbook/observability/log-vs-metric-vs-trace/)