# C++


## 面对对象
2.3
把具体数据和运算分离有它的优势，比方说，能够随心所欲地使用数据。 但是，想让用户定义类型具有“真正的类型”那些属性，就需要让数据和运算结合得更紧密些。 具体而言，我们通常希望数据表示对用户不可访问，从而避免被使用， 确保该类型数据的使用一致性，这还让我们后续能够改进数据表示。 要达成这个目的，必须区分类型的（供任何人使用的）接口和（可对数据排他性访问的）实现。 这个语言机制叫做类（class）。 类拥有一组成员（member），成员可以是数据、函数或者类型成员。 接口由类的public成员定义，而private成员仅允许通过接口访问。
定义构造函数，就类消除了类的“变量未初始化”问题。
很多情况下，使用variant都比union更简单也更安全。
3
第一步也是最重要的一步，是区分接口和实现。 这语言层面上，C++用声明表示接口，定义是实现
3.5
这种抽象的一个影响是：在程序运行时，把故障的检测点和处理点相互分离。 当程序增大，尤其是库被广泛应用，错误处理的标准化就愈加重要了。 在程序开发的早期就规划错误处理规划的策略，是个好主意。
3.6.2
只有在把不属于函数局部作用域的东西转给调用者时，才通过“传引用”返回
3.7 都还不错 看看

5.3
在采用垃圾回收器之前，请先系统化地使用资源执柄： 让每个资源都有个位于某个作用域内的有所有者，并且所有者在作用域结束处释放该资源。

在C++里，这叫 RAII（资源请求即初始化 Resource Acquisition Is Initialization）， 它已经跟错误处理机制中的异常整合在一起。 资源可以通过转移的语意或者“智能指针”，从一个作用域移到另一个作用域， 还可以通过“共享指针（shared pointer）”表示共享的所有权。

5.4
为了让类更好用，有一些约定俗成的接口需要实现
### 语义
**`=`可以用于初始化和赋值，但两者语义本质是不同的**
初始化语义可以理解为对为初始化的内存的写入操作，也就是说对于为初始化的变量的使用（内存读取和写入）都是未定义行为（特别是未初始化的引用），变量生命周期仅有一次初始化。
赋值语义可以理解为简单的内存复制操作（MOV指令），变量生命周期中可以有多次赋值操作。

引用类型的特殊性可以很好的解释上述初始化语义和赋值语义的区别。
引用类型的初始化将绑定引用变量和被引用的变量。
引用类型初始化后的赋值将不改变引用的内存（即引用变量和被引用的变量绑定关系），而是给被引用的对象赋值（即访问被引用变量的值是自动（隐式）的。从这个角度看，引用就是c++提供的一种语法糖，使用上和普通变量一样）

### 类型区分
1. 实体类型：包含数据本身和对数据的操作定义
1.1. 普通类型
1.2. 容器类型：是一个普通类型的集合，且包含对这个数据集合的操作定义。
2. 抽象类型：进一步抽象，放弃包含具体的数据和数据类型，仅包含对数据的操作定义，即接口，由派生类实现其接口。抽象类的虚函数需要动态绑定，因此，多数场景下，其通过引用或指针进行操作，也正是过引用或指针进行操作提供了其灵活性

### 类的定义与实现
如果一个类X的析构函数中有一些不容忽视的任务，比如自由存储区资源回收或者释放锁，那这个类很可能就需要实现一整套类的基本操作：
> 推荐使用**零规则（the rule of zero））**： 要么定义全部基础操作，要么全不定义（全用默认实现）。
``` c++
class X {
    // 可以为成员变量提供默认初始值
public:
    X(Sometype)             // “常规构造函数”：创建对象
    X();                    // 缺省构造函数
    X(const X&)             // 拷贝构造函数
    X(X&&);                 // 转移构造函数
    X& operator=(const X&); // 拷贝赋值：清理目标对象并拷贝
    X& operator=(X&&);      // 转移赋值：清理目标对象并转移
    ~X();                   // 析构函数：清理资源
    // ...
};
```
对数据类型存在一些基本假设，将这类基本假设实现不变式，不满足不变式时拒绝运行（抛出异常）。
**为类制定不变式（以确保成员函数有的放矢）的职责归构造函数， 而成员函数运行完成之后，要确保不变式依然成立。**

#### 构造函数
构造函数的语义是**初始化**

##### 常规构造函数和缺省构造函数
用户自主创建（临时）对象时调用
其中可以依靠这种构造函数显示指定强制类型转换的实现
```c++
class Vector {
public:
    explicit Vector(int s); // 不会隐式从int转换到Vector，类型转换时会调用这个构造函数，而且尽量把explicit用于单参数的构造函数
    // ... 
};
```

##### 拷贝构造
在类内部具有指针成员变量时（常见于大多数**容器类**），最好手动时实现
一般在如下场景调用
1. 通过一个同类型的对象为一个对象初始化
2. 作为函数参数传入
3. 作为函数参数传出
4. 作为一个异常

有时会想显示控制默认实现的生成,默认的实现就是对所有成员变量的值的逐个拷贝复制
```c++
class Y {
public:
    Y(Sometype);
    Y(const Y&) = default;  // 我确定想要默认的拷贝构造函数
    Y(Y&&) = default;       // 以及默认的转移构造函数
    // ...
};
```
有时还会需要指定不生成实现，比如基类中就不希望其将成员逐个拷贝复制
```c++
class Shape {
public:
    Shape(const Shape&) =delete;            // 没有拷贝操作
    Shape& operator=(const Shape&) =delete; // 没有拷贝赋值操作（主要是说明一下=delete的用处）
    // ...
};
```

#### 赋值
赋值语义是内存复制操作，只有相同类型才有相同的内存布局，才能赋值。所以这里仅说明拷贝赋值
与上述**拷贝构造**做区分，是在赋值操作时调用，这也侧面印证了**初始化和赋值本质上是不同的**
与上述**拷贝构造**相同的是，在类内部具有指针成员变量时（常见于大多数**容器类**），最好手动时实现
```C++
class Vector {
private:
    double* elem;   // elem指向一个数组，该数组承载sz个double
    int sz;
public:
    Vector(int s);                          // 构造函数：建立不变式，申请资源
    ~Vector() { delete[] elem; }            // 析构函数：释放资源

    Vector(const Vector& a);                // 拷贝构造
    Vector& operator=(const Vector& a);     // 拷贝赋值

    double& operator[](int i);
    const double& operator[](int i) const;

    int size() const;
};
```
#### 转移 move语义
对于多数**容器类**，拷贝复制（深拷贝）操作代价高昂
一些场景下，被拷贝复制的变量，在未来将不被使用（内存读取和写入），则可以通过转移（浅拷贝）操作来减少操作成本，提高性能。
对象（及其资源）的生命周期与其作用域强相关，转移语义的含义是将一个作用域内的对象的资源（以较低的成本）转移到另一个作用域的对象，以改变对象内资源的生命周期。
转移语义的实际实现由类的转移构造函数和转移赋值函数实现
```c++
class Vector {
    // ...

    Vector(const Vector& a);            // 拷贝构造函数
    Vector& operator=(const Vector& a); // 拷贝赋值函数

    Vector(Vector&& a);                 // 转移构造函数
    Vector& operator=(Vector&& a);      // 转移赋值函数
};
```
根据传入的参数类型，类在使用中会自动从拷贝函数和转移函数中选择相应的函数执行。
需要转移（浅拷贝）操作时，就需要传入`Vector&& a`类型，这种类型就是右值（引用）类型。
一般化的理解，只可以出现在`=`的右边的就是一个右值(rvalue)，右值不可以出现在左边。我的理解是因为在传统编译器实现中,代码中`=`右边的token，一般在最终的汇编代码中会体现为一个寄存器上的值或是一个立即数（Immediate Value），作为指令的操作数是不出现在内存上的。所以一般右值的特征是临时的、匿名的、没有持久状态的、不能取地址（暂存于栈和寄存器上）的。
常见的右值包括：
1. 临时变量
2. 函数的返回

某些情况下，我们希望对一些是左值的变量做转移（浅拷贝）操作来减少代价（这种变量一般转移后就不会再使用了），此时就会使用`std::move(左值)`，`std::move()`只是一个类型转换器，将左值转为右值。如上所说，真正的转移操作在类的移动构造函数和移动赋值函数中实现。

##### 万能引用与完美转发 universal references and perfect forwarding
还有一个理解上有难度的点，c++中类型声明`&&`并不总代表右值引用类型
当类型声明表现为是`T &&`且T是一个被推导的类型（如auto、模板类型T）时，其类型就是一个万能引用。会根据传入的参数类型匹配为新类型
1. T &&碰到右值int &&， T匹配成int；
2. T &&遇到左值int ，也能匹配，T此时是int &。
3. T &&碰到左值const int，T匹配为 const int &。
4. T &&碰到左值const int *（指针类型）, T匹配为const int *& (下略）
5. T &&碰到左值const int * const（指针类型), T匹配为const int *const & （下略）

基于此，万能引用作为参数时，右值变量会被匹配为一个左值变量，则在这个函数中对这个变量使用时，其就和传入时的类型不同了（无法被作为右值调用转移（浅拷贝）操作），这就是这个变量作为右值被**不完美地转发**到了这个函数中。此时函数中就需要使用`std::forward<T>()`来保证其与传入时的类型保持一致，以达成完美转发。
> Fowarding Reference即当T &&和std::forward结合起来的时候，可以完美的传递其参数的category和const限定。
> X& &, X& &&, X&& & all collapse to X&
> X&& && collapses to X&&

## 模板

## 参考
1. A Tour of C++
2. C++ primer