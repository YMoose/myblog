# C++
## 
`=`可以用于初始化和赋值，但两者本质是不同的
赋值可以理解为简单的内存复制操作（MOV指令）
引用的赋值，不改变他引用的目标，而是给引用的对象赋值（即访问引用所指的值是自动（隐式）的。从这个角度看，引用就是c++提供的一种语法糖，本质上和普通变量一样）
初始化可以理解为对为初始化的内存的写入操作，也就是说对于为初始化的变量的读取和写入都是未定义行为（特别是未初始化的引用）。

## 面对对象
### 类型区分
1. 实体类型：包含数据本身和对数据的操作定义
1.1. 普通类型
1.2. 容器类型：是一个普通类型的集合，且包含对这个数据集合的操作定义。
2. 抽象类型：进一步抽象，放弃包含具体的数据和数据类型，仅包含对数据的操作定义，即接口，由派生类实现其接口。抽象类的虚函数需要动态绑定，因此，多数场景下，其通过引用或指针进行操作，也正是过引用或指针进行操作提供了其灵活性
### 类的定义与实现
如果一个类X的析构函数中有一些不容忽视的任务，比如自由存储区资源回收或者释放锁，那这个类很可能就需要实现一整套类的基本操作：
> 推荐使用零规则（the rule of zero））是： 要么定义全部基础操作，要么全不定义（全用默认实现）。
``` c++
class X {
    // 可以为成员变量提供默认初始值
public:
    X(Sometype)             // “常规构造函数”：创建对象
    X();                    // 缺省构造函数
    X(const X&)             // 拷贝构造函数
    X(X&&);                 // 转移构造函数
    X& operator=(const X&); // 拷贝赋值：清理目标对象并拷贝
    X& operator=(X&&);      // 转移赋值：清理目标对象并转移
    ～X();                  // 析构函数：清理资源
    // ...
};
```
#### 常规构造函数和缺省构造函数
用户自主创建（临时）对象时调用
其中可以依靠这种构造函数显示指定强制类型转换的实现
```c++
class Vector {
public:
    explicit Vector(int s); // 不会隐式从int转换到Vector，类型转换时会调用这个构造函数，而且尽量把explicit用于单参数的构造函数
    // ... 
};
```
#### 拷贝构造和转移构造函数
有时会想显示控制默认实现的生成,默认的实现就是对所有成员变量的值的逐个拷贝
```c++
class Y {
public:
    Y(Sometype);
    Y(const Y&) = default;  // 我确定想要默认的拷贝构造函数
    Y(Y&&) = default;       // 以及默认的转移构造函数
    // ...
};
```
有时还会需要指定不生成实现，比如基类中就不希望其将成员逐个复制
```c++
class Shape {
public:
    Shape(const Shape&) =delete;            // 没有拷贝操作
    Shape& operator=(const Shape&) =delete;
    // ...
};
```
在类内部具有指针成员变量时，最好手动时实现
一般在如下场景调用
1. 赋值给另一个对象
2. 为一个对象初始化
3. 作为函数参数传入（其语义是初始化）
4. 作为函数参数传出（其语义是初始化）
5. 作为一个异常
#### 拷贝赋值和转移赋值运算符
赋值操作时调用

## 参考
1. A Tour of C++



2.3
把具体数据和运算分离有它的优势，比方说，能够随心所欲地使用数据。 但是，想让用户定义类型具有“真正的类型”那些属性，就需要让数据和运算结合得更紧密些。 具体而言，我们通常希望数据表示对用户不可访问，从而避免被使用， 确保该类型数据的使用一致性，这还让我们后续能够改进数据表示。 要达成这个目的，必须区分类型的（供任何人使用的）接口和（可对数据排他性访问的）实现。 这个语言机制叫做类（class）。 类拥有一组成员（member），成员可以是数据、函数或者类型成员。 接口由类的public成员定义，而private成员仅允许通过接口访问。
定义构造函数，就类消除了类的“变量未初始化”问题。
很多情况下，使用variant都比union更简单也更安全。
3
第一步也是最重要的一步，是区分接口和实现。 这语言层面上，C++用声明表示接口，定义是实现
3.5
这种抽象的一个影响是：在程序运行时，把故障的检测点和处理点相互分离。 当程序增大，尤其是库被广泛应用，错误处理的标准化就愈加重要了。 在程序开发的早期就规划错误处理规划的策略，是个好主意。
3.6.2
只有在把不属于函数局部作用域的东西转给调用者时，才通过“传引用”返回
3.7 都还不错 看看