# 代码里的坏味道
何时应该采取重构的措施？首先需要闻到代码里的坏味道
## 坏味道
> 坏味道只是表象，需要挖掘坏味道更深层次的设计原因，以下指出了一些坏味道，书中有针对坏味道具体的解决方法
1. Duplicated Code 重复代码 -> 责任划分，重复的代码有相同的功能，设计时可以把功能提取出来
2. Long Method 过长的函数 -> 可理解性，过长的函数导致难以理解，且函数内部分功能难以得到服用
3. Large Class 过大的类 -> 责任划分，过大的类包含过多的责任，设计时需要拆分
4. Long Parameter List 过长参数列 -> 可理解性，过长的参数列导致难以理解，且可能导致参数管理复杂
5. Divergent Change 发散式变化 -> 责任划分，当某段代码可能因为多种变化而修改，说明这段代码责任可以进一步划分
6. Shotgun Surgery 霰弹式修改 -> 责任划分，是5的反向，当某种变化可能引起多段代码修改，说明这多段代码的职责可以进一步抽象合并
7. Feature Envy 依恋情结 -> 责任划分，某段代码过度依赖于另一段代码（数据）
8. Data Clumps 数据泥团 -> 可理解性，将部分常用变量整合到一个数据类中，减少管理的复杂性
9. Primitive Obsession 基本类型偏执 -> 可理解性，将部分常用变量整合到一个数据类中，减少管理的复杂性，和8很像
10. Switch Statement switch跳转 -> 提高复用，switch跳转语句常常会跟随重复的代码，可以用多态去替换
11. Parallel Inheritance Hierarchies 平行继承体系 -> 责任划分，6的特殊情况，专指增加子类时，必须连带增加另一个子类。
12. Lazy Class 冗赘类 -> 精简代码，删除无需使用的类及相关接口
13. Speculative Generality 夸夸其谈未来性 -> 精简代码，删除当前无需使用的类、相关接口及设计，和12有相交的部分，这个是我本人常犯的错误，过度设计，确实没必要
14. Temporary Field 令人迷惑的暂时字段 -> 可理解性，将某些特殊情况专用的变量提取出去
15. Message Chains 过度耦合的消息链 -> 面向修改，过长的函数调用链，导致客户代码与查找过程中的导航结构紧密耦合。一旦对象间关系变化，客户端就需要相应修改
16. Middle Man 中间人 -> 责任划分，把过多的责任都整合到了中间人上
17. Inappropriate Intimacy 狎昵关系-> 责任划分，两个类过度亲密，通常由继承造成，因为子类对父类的了解总是超过父类的想让子类知道的
18. Alternative Classes with Different Interfaces 异曲同工的类 -> 精简代码，类似功能的函数同时存在
19. Incomplete Library Class 不完美的库类 -> 外部环境，需要开发部分自定义的功能完善库
20. Data Class 纯稚的数据类 -> 责任划分，在8的基础上对数据类的操作进行封装
21. Refused Bequest 被拒绝的遗赠 -> 责任划分，继承的子类对超类部分复用实现，但又不愿意支持其接口
22. Comments 过多的注释 -> 可理解性，用代码代替注释