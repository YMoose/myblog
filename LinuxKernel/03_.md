# 并发问题
在计算机追寻计算性能的发展道路上，单核CPU性能遇到功耗墙，然后走向多核道路。在走上多核道路后，此前已经存在的单核CPU的性能优化方案给多核cpu带来了更复杂的挑战，这就是多核并发的挑战
核心问题是共享内存上的数据读写顺序（从另一个角度看也就是数据相关性问题）无法保证，因为和共享内存相关只有在多核处理器上才有
## 单核CPU上的优化导致的多核并发问题
计算机学科在发展中不断地对计算性能进行着优化。但部分针对单核性能的优化导致了并发问题。
下列优化在单核cpu上都不会引发内存一致性问题，但是当多核访问同一个共享内存时，就有可能会导致问题。
### 1. 编译优化
在1970年代，Frances E. Allen和 John Cocke一起提出了一种称为"规则依赖分析"（Dependency Analysis）的编译器优化技术。该技术可以自动识别程序中的数据依赖关系，并利用这些信息来进行指令重排和其他优化。通过减少数据相关性依赖，使得指令执行时减少（指令流水线中的取存阶段的）等待时间以及提升分支预测准确率，同时为后续的指令乱序执行进行预优化。其中指令重排就会使得编译后的机器指令并不完全按照程序编写人员编写的顺序执行。但这样的指令重排受限于上述的数据依赖关系，不会影响程序执行的结果。
### 2. 指令优化
经过编译优化后的指令在处理器上执行。处理器将一部分数据相关性的问题带到硬件设计中解决，通过数据无关的指令并行执行以提高效率。 现代乱序处理器中单个逻辑CPU中指令首先被处理器前端译码，然后被分派到各自的处理管线中执行，cpu中有多条处理管线同时运行，也就是说多条指令在多条流水线上并行执行。与编译优化类似，乱序执行受限于上述的数据依赖关系，不会影响程序执行的结果。
### 3. 缓存优化
为了填补cpu速度与内存存取速度的鸿沟，cpu提出了多级存储架构。在多数现代处理器架构中，每个逻辑cpu有自己的本地cache。
## 解决方法 
编译顺序一致性: 编译屏障
指令乱序执行顺序一致性: 内存屏障
缓存一致性: 读写屏障
## 最终解决方法————锁

## 参考
0. chatgpt
1. [编译器架构历史](https://en.wikipedia.org/wiki/History_of_compiler_construction)


## 例子
读写指令穿插