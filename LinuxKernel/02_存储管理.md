# 2. 存储管理
## 2.1 Linux内存管理的基本框架
Linux内核的映射机制设置为三层：
- PGD->PMD->PE->PA
虚拟Linux内存管理单元分成四步:  
1. CR3寄存器上的PGD作数组指针[内存里的页面目录(PGD)下标]->中间目录(PMD)数组指针
2. 中间目录(PMD)数组指针[内存里的中间目录(PMD)下标]->页面表(PT)数组指针
3. 页面表(PT)数组指针[内存里的页面表(PT)下标]->页面表项(PTE)(也即真实物理页面首地址)
4. 真实物理页面首地址[内存里物理页面下标]=真实物理地址  

linux内核将内存空间分成两部分，最高的1G字节(逻辑地址0xC0000000~0xFFFFFFFF会被映射到物理地址的0x00000000~0xBFFFFFFF), 若Linux需要操作1G以外内存空间的内存，使用的是修改填充内核空间PTE以ZONE_HIGHMEM(逻辑地址空间)访问其他内存空间的内存。  

GDT(全局段描述符表)的表项包括：
0. 第0项: 0(防止在加电后，段寄存器未经初始化就进入保护模式并使用GDT)
1. 第1项：永远是0
2. 第2项：内核代码段
3. 第3项：内核数据段
4. 第4项：当前进程的代码段
5. 第5项：当前进程的数据段
6. 其他进程的LDT(局部段描述符表)
7. 其他进程的TSS(任务状态段)
## 2.2 地址映射的全过程
### 内存管理方式
页式存储优点：
- 固定大小，方便管理
- 当与硬盘发生交换时，代价相比段式存储小  

一般会根据硬件选择映射方式。因为历史原因，i386采用先段式映射再页式映射的方式。
### 实际流程
以一个命令跳转指令call 0x08048568来看：
1. 先进行段式映射:
   1. CPU的指令计数器EIP指向0x08048568(为程序执行代码位置)，所以其在代码段中。=>用代码段寄存器CS来作为段式映射的段
   2.  解析段寄存器CS。根据段寄存器的定义，查看此段寄存器使用的是GDT还是LDT(通常内核代码使用GDT，用户进程代码使用LDT)，段寄存器最低两位RPL为所要求的特权级别。内核在建立进程时会(通过宏start_thread(include/asm-i386/processor.h))设置其段寄存器
   3.  查看start_thread后可以看到linux在设置段寄存器时使用的段描述符模板基本上s都使用的是GDT(linux内核中基本不使用LDT。只有VM86模式中运行wine或模拟windows时会使用LDT)
   4.  查看全局段描述符表GDT，初始GDT的内容在arch/i386/kernel/head.S中定义且主要内容在运行中基本不变
   5.  在全局段描述表GDT中各项显示段基址全为0，段长度全为4G(0xffff ffff ffff ffff)即每个段都是从0开始的整个4G逻辑地址空间，也即段映射后的线性地址与逻辑地址的值相同
2. 进入页式映射
   1. 页式映射第一级找到PGD(页面目录): MMU会以控制寄存器CR3的值为PGD的指针，PGD的指针是保存在每个进程的mm_struct数据结构中，每当切换进程时由inline函数switch_mm(include/asm-i386/mmu_context.h)对CR3进行设置(注意这里会将PGD地址先转化为物理地址再放置)，设置完成后代码还在内核空间中运行(即使用相同的页面映射，即用户进程设置的PGD的页面映射和内核进程的PGD的页面映射在映射逻辑地址中的内核内存空间时，采用的是一样的映射)
   2. 取逻辑地址的高10位作为偏移，在PGD中找到目录项，根据偏移找到的目录项的高20位和后面12个0拼接为页面表指针。为什么取12个零点原因为，每个页面表占一个页面(4KB对齐，一个地址4B，所以一个页面表中存放1024个页面地址指针)。同时目录项不用的后12位可以记录别的信息(比如最低为为P标志位，表明页面表是否在内存中)，类似
   3. 取逻辑地址的中间10位作为偏移，在PT中找到目标项(PTE)，并推出物理内存页面指针
   4. 取逻辑地址的末12位为偏移，在物理内存页面中找到物理地址  

在现代计算机中会将PT和PTE装入cache中加快访问速度，另外整个过程由硬件实现，相对较快
### 其他
linux为了仿真运行段式存储软件还提供了两个相关的系统调用
1. modify_ldt(int func, void *ptr, unsigned long bytecount)
   可以改变当前进程的局部段描述表为`ptr`指向的一个结构modify_ldt_ldt_s中设置的局部段描述表(段式存储转换后是线性地址，所以仍然在页式存储的管理下)
2. ym86(struct vm86_struce *info)
   用于模拟另一种寻址方式VM86，用来在保护模式下模拟运行实地址模式的软件
## 2.3 重要的数据结构和函数

