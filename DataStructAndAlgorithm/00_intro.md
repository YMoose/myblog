# 数据结构与算法
## 算法
算法是用于获取问题的解的步骤的描述
满足问题的约束的解可能存在
1. 无可行解（一元二次方程无实数解）
2. 单一可行解 （一元一次方程组求解）
3. 多个可行解（可能是有界集合（不求最优解的背包问题），也可能是无界集合（帮我作诗一首））
进一步地，存在一类问题是在可行解中找到最优解，此类问题称为最优化问题，最优化问题的解在有可行解的前提下至少存在一个最优解。
对问题，需要用复杂程度来度量，复杂程度从计算机的角度来度量就是解决问题过程中所需的资源（存储空间）和算法复杂度（直观反映为执行的指令数量（能耗和时间））
一个问题可能由多个子问题组成，所以解决一个问题的算法可能由多个子算法组成，算法和子算法完全可以采取不同的策略思想。
算法的区别在于寻找解时如何做出下一步的决策，比如，启发，分治，暴力枚举，随机进化，梯度拟合。（todo:可以分析一下决策各自适用的问题的解的数量情况）
### 暴力搜索 Brute-force search
也称为枚举法、穷举法。遍历问题的可能解空间，并带入问题约束检验，从而从一系列可能解中获得可行解。从另一个角度可以看作最简单的近似算法
#### 回溯算法 Backtracking
也称为回溯剪枝。尤其适用于约束补偿问题，在解决约束满足问题时，对于所有候选解，在（暴力）搜索过程中，如果确定某一部分候选解不可能补全成正确解之后，则放弃继续搜索这部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解，会节省一定的工作量
### 分治算法 Divide and Conquer
问题可以拆解为两部分：
分：将原问题分解为结构相似的子问题
治：对子问题的解进行计算构建得出原问题的解。
对分治算法的运行时间进行递推估算的时候，可以使用主定理进行分析
[Master Theorem](pics/MasterTheorem.png)
#### 递归 Recursion
分治算法典型，从原问题开始拆解：
一部分是结构相似的子问题，一种是基本子问题，可以直接计算返回基本子问题的解，另一种非基本子问题，调用递归算法继续拆封解决。
另一部分是对子问题的解进行计算得出原问题解的步骤。
常见递归算法解决的问题含有以下特征
1. 问题可以被逐步分解到基本子问题
2. 子问题之间求解过程相对独立（即子问题之间不包括公共的子子问题，不然会使得算法所需资源浪费且爆炸增长）。
复杂问题可以通过先实现为递归算法理解问题的本质，并进一步实现为非递归（比如循环）的实现，使得不依赖于函数递归调用，编译器可以生成在现实中相对高效的算法
- 对于线性递归中的尾递归可以很自然地通过循环实现（修改函数参数，跳转到函数入口执行）
- 对于递归算法中子问题不独立则，借助一定量的辅助空间，在各子问题求解后，及时记录下对应的解供后续算法使用————每次检查是制表法，由递归基出发是动态规划
#### 递推 
可以理解为递归的逆过程，从基本子问题开始，经过计算推出子问题的解，子问题经过计算推出原问题的解
##### 动态规划 Dynamic programming
问题通常无法被分解为一个独立解决的单元，从原问题到基底问题的推导过程中，子问题分支变多，通常导致指数级的增长，使得问题变得异常困难,所以不适用于递归。此时可以从基底问题的方向倒推，使用递归，将问题从基本子问题开始推导，与贪心算法不同的是其穷举并记录了子问题的解，并最终从中选择全局最优解。
常见动态规划算法解决的问题含有以下特征：
1. 问题推导无后效性：即子问题的解一旦确定，就不受这个子问题拓展出的后续问题的影响。
2. 有重叠子问题（Overlapping Subproblems）：即子问题之间不独立，一个子问题的解在后续的计算步骤中可能被多次使用到。
### 近似算法
面对问题，通常会建立问题的数学模型，但某些复杂问题的数学模型会在问题规模增大的同时，算法耗费的时间、资源以指数甚至更高阶次增长（即NP-Hard问题）。近似算法通过牺牲精度以控制复杂度增长的策略设计算法步骤，期望在有限时间内找到最优化问题的近似解。
#### 贪心算法 Greedy algorithm
将问题从一个最优子结构开始推导，每一步推导根据上一步推导出的最优子结构结果为基础进行最优解的计算，并将最终推导结果认定为近似最优解（仅为最后一步推导中的最优解，并非一定是全局最优）。属于一种简单的近似算法
#### 启发算法 Heuristic Algorithm
启发式算法是通过一个启发函数对下一阶段状态进行粗略评估，这个评估是预计结果（并不确信）
具体有：禁忌搜索/遗传算法/进化算法/模拟退火算法/蚁群算法/人工神经网络等等。
### 随机化算法
todo
## 算法分析
### 正确性
### 性能
不同的计算模型可能导致不同性能，现在普遍使用与现代计算机相同的RAM(Random Access Machine，随机访问机器)作为分析时的计算模型。
## 数据结构
在获取问题的解的时候，需要存放算法过程中的数据。
数据结构本质上是数据的组织形式，目的是提高算法运行的效率而要将数据高效地组织起来以供算法存取使用，所以通常要与算法一同设计。
一般来说，数据结构需要经过构建（build）后才能被使用
算法中对于数据的操作可以归结为增加（Create）、查询（Retrieve）、更新（Update）和删除（Delete）这四种基本操作，通常被简称为 CRUD 操作
增：从数据的整体中增加后，数据整体重新组织为可用状态
查：根据数据组织后的秩或者根据数据元素的值对数据整体中已存储的数据元素进行查找
改：改变已存储的数据元素内容
删：查询到所需要删除的数据，从数据的整体中删除后，数据整体重新组织为可用状态
### 线性数据结构
数据的组织在逻辑上是顺序的，数据间的联系是线性的，数据组织的熵最小
队列（FIFO）和栈（FILO）数据结构都由此发展而来
#### 数组 vector/array
数据的组织不仅在逻辑上是顺序的，在物理（内存）上也是顺序的
增：顺序插入O(1)，随机插入O(n)
查：通过秩查找O(1)，通过数据值二分查找O(logn)，通过数据值遍历查找O(logn)
改：O(1)
#### 链表 list
对于非顺序的单个或者连接了的多个数据插入删除非常方便。但是链表是通过牺牲数据物理组织（内存上的排布）的有序性为代价换取的灵活的数据增删操作。
增：顺序插入O(1)，随机插入O(1)
查：基本与数组相似，但查询访问数据时的内存访问模式较难利用缓存的优势。
改：O(1)
### 半线性数据结构
#### 树 tree
树是链表的变式
### 非线性数据结构
#### 图 graph
## 参考
1. https://www.lumin.tech/articles/algorithmic-paradigm/
2. https://zhuanlan.zhihu.com/p/161989297
3. https://www.cnblogs.com/gaochundong/p/algorithmic_paradigms.html