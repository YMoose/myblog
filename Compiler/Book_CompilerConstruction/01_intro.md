# Intro
## 1. Compilers History
1. 最初是机器码的二进制纸带
2. 汇编语言->汇编器->二进制
3. 高级语言FORTRAN：编译器的开发过程中一些编译原理的知识还没有得到总结和研究
4. Chomsky研究了自然语言的结构，针对语言的语法复杂程度进行了分类，提出了Chomsky hierarchy，其中type2（context-free 上下文无关）语法被证明是最有用的编程语言。有穷自动机和正则表达式是type3类语法
5. 解析问题得到了更完善的解决，并逐步成为了编译器中的标准部分。
6. 为了追求更好的编译和执行效率，研究人员不断地研究和提高优化技术（代码提升技术）
7. 研究人员依据逐步完善的解析问题解决方案开发出了解析器生成器（比如：yacc）
8. 另一方面，研究人员对有穷自动机的研究逐步深入，开发出了另一种工具——扫描器生成器（比如：Lex）
9. 近来，一部分编译器发展了一些对代码的分析简化技术，同时集成进了IDE
## 2. 与编译器相关的程序
### 2.1. 解释器 iterpreters
没有生成目标代码的步骤，直接翻译执行。通常适用于代码常常修改调整的教学和软件开发场景。
### 2.2. 汇编器 assemblers
将汇编代码转换为目标机器码
### 2.3. 链接器 linkers
编译器和汇编器都需要链接器的参与，链接器将目标文件中分散的目标代码片段进行组合填充为一个真正的可执行文件
### 2.4. 加载器 loaders
加载器解析**可重定位代码**，找到可执行文件的起始点并开始执行。
### 2.5. 预处理器 preprocessors
对代码文件的预处理，包括处理注释、头文件、**宏**等
### 2.6. 调试器 debuggers
一般来说，会和编译器一起提供，编译器会保留一些信息（符号信息）给调试器调试时使用，以帮助更好的获取运行时程序的状态信息
### 2.7. profilers
profilers会采集运行时的统计信息帮助分析
## 3. translation process
![编译过程](pics\figure1_1_the_phases_of_a_compiler.png)
1. scanner：输入源代码->进行词法分析（lexical analysis）->生成tokens，同时会需要将一些数据写入到符号表和字面量表中
2. parser：输入tokens->进行语法分析（syntax analysis）->生成parsing tree后优化为语法树（syntax tree）\抽象语法树（abstract syntax trees）
3. semantic analyzer：输入syntax tree->根据语言的定义分析静态语义（执行优先级、声明和类型检查）->带有属性标记的语法树，同时会把属性加入到符号表中
4. source code optimizer：输入带有属性标记的语法树->基于源码分析生成中间码（通常是三地址码 three-address code 或 P-code）并对其进行优化->intermediate representation (IR)
5. code generator：输入IR->根据目标机器的指令集架构（ISA）生成目标代码（target code）->目标机器码（target code）
6. target code optimizer：输入目标机器码->分析目标机器码并优化（高效指令替换低效指令、访存效率提升等）->优化后的目标机器码（target code）
## 4. Data Structures In A Compiler
1. tokens: 文本识别后的最小单元，同时会包含文本、位置信息、类型信息等属性
2. the syntax tree: 对token组成的单元的抽象，不同的节点中会包含一些不同属性
3. the symbol table: 通常用hash表来保存标识符、变量、常量和数据结构的相关信息。几乎参与到整个编译过程中。
4. the literal table: 通常用hash表来保存字面量，例如字符串、常量等，不可删除。
5. intermediate code: 通常使用三地址码或P-code形式来表示
6. temporary files: 以往会因为内存不足而使用临时文件保存一些中间结果，比如代码生成时的回填地址（backpatch addresses）
## 5. Compiler Structure
编译器从不同的视角看有不同的结构和组成部分
### 5.1. Analysis and Synthesis
analysis: 分析源代码得出程序作用
synthesis: 综合程序作用生成目标代码
### 5.2. Front End and Back End
front end: 分析源代码，生成中间代码（intermediate code）或抽象语法树（abstract syntax tree）等中间表示（intermediate representation）
back end: 综合中间表示生成目标代码
### 5.3. Passes 
在生成目标代码，甚至中间代码前，编译器倾向于多次扫描处理源代码。每过一遍源代码称为一次pass。
### 5.4. Language Definition and Compilers
language reference manual（language definition）：用正则表达式和上下文无关语法描述的语言规范，其逻辑体现在词法分析和语法分析中。还有事用数学语言对语言语义的形式化描述（方法有Denotational Semantics、Operational Semantics、Axiomatic Semantics）。
runtime environment：运行时环境的支持度很大程度地影响了对语言和编译器实现的复杂度
### 5.5. Compiler Options and Interfaces
提供给用户的编译器选项和编译器使用的接口
### 5.6. Error Handling
反映源代码中存在的错误
一般可以分类为两类错误，语法错误和语义错误
## 6. 自动机理论与形式语言
### 6.1. 自动机理论
自动机是一种数学抽象逻辑模型，可以用于判定。
自动机具有读入装置，读入装置一次读入条带上的一个符号，符号来自于预定义的字母表。
自动机具有控制装置，控制内部结构被简单地描述为一组有限的状态，其中存在一个唯一的当前状态。
部分自动机模型有存储装置，（控制装置可以看作是一个特殊的存储器仅能存储有限状态中的其中一种，类似于单个寄存器但寄存器位数视状态数量而定）。
自动机在离散的时间框架上操作
1. 在任意给定的时间点上，控制部件处于某个内部状态上（当前状态） 输入装置读取符号条带的一个符号。
2. 下一时刻，控制装置处于哪一个内部状态由转移函数（transition function）决定。
在上述过程中，自动机会产生输出，或改变存储装置中的信息
如果一个自动机的输出响应仅限于判定是或否的话，这个自动机就是接收器（accepter）
如果一个自动机的输出可以输出与输入相同的符号，这个自动机就是转换器（transducer）
### 6.2. the chomsky hierarchy 乔姆斯基谱系
语言学家诺姆·乔姆斯基（Noam Chomsky）基于自动机理论提出了生成语法理论，并结合这一理论对接收器进行了有益的分类。语法是语言的生成器，自动机是语言的接收器
自动机理论中提出4种自动机，主要区别在于其能使用的存储空间的差异
乔姆斯基将不同自动机可以识别的不同文法语言也同样分为了4类语言（及其对应文法）
一种语言的文法G，用形式化手法表现为
```
G = (V, T, P, S)
推导（derivation/production，=>） P:指通过一系列替换操作从一个开始符号推导出一个句子的过程。一次替换操作只能应用一条语法规则。不同类型的语言的区别主要在于推导式的限制上。
终结符号 T：组成句子（串）的基本符号（与tokens含义相同）是推导的终结。于上面的例子就是 number、（和）
非终结符号 V：表示用于由文法生成的句子的集合，非终结符号可以由终结符号和其它非终结符号组成，最终推导至全为终结符号。于上面的例子就是 exp 和 op。
开始符号（start symbol）S：一个特殊的非终结符号，表示文法生成的最基本的句子的集合，成为句型（即文法的定义的最基本语言）。于上面的例子就是 exp。
```
L(G)表示由文法G定义的语言，即由G生成的所有句子的集合。
### 6.2.1. type3 正则语言 - 有限状态机（FSM Finite-state machine）：存储有限的状态
#### 6.2.1.1. 正则文法表示
正则文法的产生式满足以下形式
```
A->Bx
A->x
A,B 属于非终结符号，且两者必须不同
x 属于终结符号。
```
A->Bx是左线性（Right Linear）文法
A->xB是右线性（Left Linear）文法
#### 6.2.1.2. 正则语言性质
##### 6.2.1.2.1. 泵引理（pumping lemma）
使用泵引理反证一个语言不是正则语言
泵引理提出假设*L*是正则语言，则存在与*L*相关的常数n满足：对于任何*L*中的串w，如果w的长度>=n，则我们就能够把w打断为三个串w=xyz，使得
1. y不等于空串，即|y|>0
2. |xy|<=n
3. 对于所有的k>=0，串xykz也属于L(yk指y重复k次)
这其中串y就是泵，其重复多次仍然可以保证结果串属于L。证明的关键就是找到并构造这个串y。
##### 6.2.1.2.2. 封闭性（closure property）
正则语言具有**封闭性（closure property）**，封闭性使得我们可以从一些语言出发经过某些计算来构造能够识别另一些语言的识别器。
以下是一些主要的封闭性运算
1. 两个正则的并、交、差以及补是正则的
2. 正则语言的反转是正则的
3. 正则的重复、连接时正则的
4. 一个正则的串作为另一个语言的符号则后者也是正则语言（同态）
5. 正则的逆同态也是正则的
##### 6.2.1.2.3. 判定性质（decision property）
正则语言具有的**判定性质（decision property）**可以解决以下基本问题：
1. 判定语言的空性：所描述语言是否为空，以一个有穷自动机来看，即从初始状态开始接受状态是否可达。
2. 判定串*w*对于语言的成员性：具体的串*w*是否属于所描述语言，以一个有穷自动机来看，可以直接用*w*在自动机上模拟
3. 判定语言的等价性：将DFA最小化后比对
##### 6.2.1.3. 有限状态机（FSM Finite-state machine）
读入装置：仅可单向读入
控制装置：一个当前状态
存储装置: 无存储装置
### 6.2.2. type2 上下文无关语言 - 下推自动机（PDA Pushdown automata）：存储有限的状态，下推存储器
#### 6.2.2.1. 上下文无关文法表示
```
A->a
A属于非终结符号
a属于(非终结符（包括A自己）或终结符号)*
```
A->Ax是左递归文法
A->xA是右递归文法
#### 6.2.2.2. 上下文无关语言性质
##### 6.2.2.2.1. 泵引理（pumping lemma）
使用泵引理反证一个语言不是上下文无关语言
泵引理提出假设*L*是上下文无关语言，则存在与*L*相关的常数n满足：对于任何*L*中的串w，如果w的长度>=n，则我们就能够把w打断为三个串w=uvxyz，使得
1. vy至少有一个不是空串，即|vy|>0
2. |vxy|<=n
3. 对于所有的k>=0，串uvkxykz也属于L(vk,yk指重复k次)
这其中串v、
y就是泵，其重复多次仍然可以保证结果串属于L。证明的关键就是找到并构造这个串v、y。
##### 6.2.2.2.2. 封闭性（closure property）
上下文无关语言具有**封闭性（closure property）**，封闭性使得我们可以从一些语言出发经过某些计算来构造能够识别另一些语言的识别器。但和正则语言不同，上下文无关语言的封闭性在很多正则语言封闭性成立的情况下不成立
1. 两个上下文无关语言的并是上下文无关语言的
2. 上下文无关语言的反转是上下文无关的
3. 上下文无关语言的重复、连接是上下文无关语言
4. 上下文无关语言的同态也是上下文无关的
5. 上下文无关的逆同态也是上下文无关的
##### 6.2.2.2.3. 判定性质（decision property）
上下文无关语言具有的**判定性质（decision property）**可以解决以下基本问题：
1. 判定语言的空性：所描述语言是否为空，以一个有穷自动机来看，即从初始状态开始接受状态是否可达。
2. 判定串*w*对于语言的成员性：具体的串*w*是否属于所描述语言，以一个PDA来看，可以直接用*w*在自动机上模拟
##### 6.2.2.3. 下推自动机（pushdown automaton）
读入装置：仅可单向读入
控制装置：一个当前状态
存储装置: 堆栈，提供符号（与字母表符号可以不同也可以相同，是两个集合）的下推（pushdown）和弹出（pop）操作
### 6.2.3. type1 上下文有关语言 - 线性有界自动机（LBA Linear-bounded automata）：存储有限的状态，下推存储器，输入输出带本身
### 6.2.4. type0 无限制语言 - 图灵机（Turing machine）：使用无限纸带作为存储
##### 6.2.4.1. 图灵机（Turing machine）
读入装置：可随意读入（Random access）
控制装置：一个当前状态
存储装置: 无限长纸带（一维数组），提供随意读写（Random access）符号（与字母表符号可以不同也可以相同，是两个集合）的操作，即存在读写头可在带上移动
## 参考
1. 《Compiler Construction: Principles and Practice》. Louden, Kenneth C. 
2. 《自动机理论 语言和计算导论（原书第3版·典藏版）》. 约翰·E. 霍普克罗夫特,拉杰夫·莫特瓦尼,杰弗里·D.乌尔曼
3. 《形式语言与自动机导论（原书第三版》. Peter Linz
4. 《计算理论导引（原书第3版）》. Michael Sipser 



